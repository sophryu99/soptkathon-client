## 쉼표 - 사운즈 여행, 당신의 방을 여행 공간으로



요즘 같은 UNTACT 시대에 *여행이 고픈 사람*들에게 어떻게하면 도움이 될 수 있을까 ⁉️⁉️



### **🌟가고싶은 여행지의 소리를 들을 수 있는 서비스**🌟

🔥류세화: 로그인 화면, 홈 화면

🔥김성은: 위치화면, 위치화면 2

🔥양재욱: 위치화면 3, 사운드 플레이 화면

<img width="400" alt="Screen Shot 2020-06-07 at 8 05 59 AM" src="https://user-images.githubusercontent.com/46921003/83956156-ee4f7680-a895-11ea-9c3c-a0421eae6c7a.png">



<img width="380" alt="Screen Shot 2020-06-07 at 8 06 15 AM" src="https://user-images.githubusercontent.com/46921003/83956160-fad3cf00-a895-11ea-97a5-e7b063d5ceb7.png"><img width="380" alt="Screen Shot 2020-06-07 at 8 06 23 AM" src="https://user-images.githubusercontent.com/46921003/83956161-00311980-a896-11ea-94d1-2ebb493479b4.png">



> 화면을 꽉 채우는 Carousel 형태의 CollectionView 만들기

```swift
extension HomeVC: UICollectionViewDelegate, UICollectionViewDataSource {
    func numberOfSections(in collectionView: UICollectionView) -> Int {
            return 1
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        if collectionView == self.ContentsCollectionView {
          // PageControl 연결
            contentPageControl.numberOfPages = contentList.count
            return contentList.count
        } else {
            return travelList.count
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if collectionView == self.ContentsCollectionView {
            guard let contentCell = collectionView.dequeueReusableCell(withReuseIdentifier: ContentsCollectionViewCell.identifier, for: indexPath) as? ContentsCollectionViewCell else { return UICollectionViewCell()}
            contentCell.set(contentList[indexPath.row])
            return contentCell
        } else if collectionView == self.TravelCollectionView {
            guard let travelCell = collectionView.dequeueReusableCell(withReuseIdentifier: TravelCollectionViewCellSH.identifier, for: indexPath) as? TravelCollectionViewCellSH else { return UICollectionViewCell()}
            travelCell.set(travelList[indexPath.row])
            return travelCell
        } else {
            guard let heartCell = collectionView.dequeueReusableCell(withReuseIdentifier: HeartCollectionViewCell.identifier, for: indexPath) as? HeartCollectionViewCell else { return UICollectionViewCell()}
            heartCell.set(heartList[indexPath.row])
            return heartCell
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        if collectionView == self.ContentsCollectionView {
            return CGSize(width: collectionView.frame.width, height: collectionView.frame.height)
        } else {
            return CGSize(width: collectionView.frame.width/1.5, height: collectionView.frame.height)
        }
    
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
            if collectionView == self.ContentsCollectionView {
                return 0
            } else {
                return 10
            }

    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        if collectionView == self.ContentsCollectionView {
            return 0
        } else {
            return 15
        }
    }
    
  // PageControl 연결하고 스크롤 기능 구현해주기
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        contentPageControl?.currentPage = Int(scrollView.contentOffset.x) / Int(scrollView.frame.width)

    }

    func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
        contentPageControl?.currentPage = Int(scrollView.contentOffset.x) / Int(scrollView.frame.width)
    }
}
```



> 옆으로 넘어가는 형태의 CollectionView 만들기

```swift
private func setHeartView() {
        // width, height 설정
        let cellWidth = HeartCollectionView.frame.width/2
        let cellHeight = HeartCollectionView.frame.height
         
         // 상하 inset value 설정
         //let insetY = (CatCollectionView.bounds.height - cellHeight) / 2.0
         let layout = HeartCollectionView.collectionViewLayout as! UICollectionViewFlowLayout
         layout.itemSize = CGSize(width: cellWidth, height: cellHeight)
         layout.minimumLineSpacing = 0
         layout.scrollDirection = .horizontal
        
         HeartCollectionView.contentInset = UIEdgeInsets(top: 10, left: 0, bottom: 10, right: 0)
         
         // 스크롤 시 빠르게 감속 되도록 설정
         HeartCollectionView.decelerationRate = UIScrollView.DecelerationRate.fast
    }
```



<img width="400" alt="KakaoTalk_Photo_2020-06-07-08-49-49" src="https://user-images.githubusercontent.com/46921003/83956712-e266b300-a89b-11ea-8094-94eaaf7ddf6e.png">



> AVAudioPlayerDelegate을 사용한 플레이화면 구현
>
> 단순히 유투브의 링크를 불러와 새로운 뷰에 동영상을 띄우고 싶지 않아 앱 내에서 플레이어 형태의 기능을 구현하게 해주는 라이브러리를 사용했다!

```swift
class PlayVC: UIViewController, AVAudioPlayerDelegate {
    
    //오디오 플레이어 인스턴스 변수
    var audioPlayer: AVAudioPlayer!
    //재생할 오디오의 파일명 변수
    var audioFile: URL!
    //타이머를 위한 변수
    var progressTimer: Timer!
    // timer selector
    let timePlayerSelector: Selector = #selector(PlayVC.updatePlayTime)

    @IBOutlet var pvProgressPlay: UIProgressView!
    @IBOutlet var lblCurrentTime: UILabel!
    @IBOutlet var lblEndTime: UILabel!
    @IBOutlet var btnPlay: UIButton!
    @IBOutlet var btnPause: UIButton!
    @IBOutlet var btnStop: UIButton!
    @IBOutlet var btnHeart: UIButton!
    @IBOutlet var lblSubTitle: UILabel!
    @IBOutlet var lblTitle: UILabel!
    @IBOutlet var lblText1: UILabel!
    @IBOutlet var lblText2: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()

        // Do any additional setup after loading the view.
        audioFile = Bundle.main.url(forResource: "IMG_9472", withExtension: "mp3")
        initPlay()   
    }
    
    func initPlay(){
        do{
            audioPlayer = try AVAudioPlayer(contentsOf: audioFile)
        } catch let error as NSError{
            print("Error-initPlay : \(error)")
        }
        
        pvProgressPlay.progress = 0
        
        audioPlayer.delegate = self
        audioPlayer.prepareToPlay()
        
        lblEndTime.text = convertNSTimeInterval2String(audioPlayer.duration)
        lblCurrentTime.text = convertNSTimeInterval2String(0)
        
        btnPlay.isEnabled = true
        btnPause.isEnabled = false
        btnStop.isEnabled = false
        
        setPlayButtons(true, pause: false, stop: false)
    }
    
    func setPlayButtons(_ play:Bool, pause:Bool, stop:Bool) {
        btnPlay.isEnabled = play
        btnPause.isEnabled = pause
        btnStop.isEnabled = stop
    }
    
    func convertNSTimeInterval2String(_ time: TimeInterval) -> String {
        let min = Int(time/60)
        let sec = Int(time.truncatingRemainder(dividingBy: 60))
        let strTime = String(format: "%02d:%02d", min, sec)
        return strTime
    }
    
    @IBAction func btnPlayAudio(_ sender: UIButton) {
        audioPlayer.play()
        setPlayButtons(false, pause: true, stop: true)
        
        progressTimer = Timer.scheduledTimer(timeInterval: 0.1, target: self, selector: timePlayerSelector, userInfo: nil, repeats: true)
    }
    
    @objc func updatePlayTime(){
        lblCurrentTime.text = convertNSTimeInterval2String(audioPlayer.currentTime)
        pvProgressPlay.progress = Float(audioPlayer.currentTime/audioPlayer.duration)
    }
    @IBAction func btnPauseAudio(_ sender: UIButton) {
        audioPlayer.pause()
        setPlayButtons(true, pause: false, stop: true)
    }
    @IBAction func btnStopAudio(_ sender: UIButton) {
        audioPlayer.stop()
        audioPlayer.currentTime = 0
        lblCurrentTime.text = convertNSTimeInterval2String(0)
        setPlayButtons(true, pause: false, stop: false)
        progressTimer.invalidate()
    }
    
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        setPlayButtons(true, pause: false, stop: false)
    }

}

```

<img width="380" alt="KakaoTalk_Photo_2020-06-07-08-49-44" src="https://user-images.githubusercontent.com/46921003/83956720-f7434680-a89b-11ea-93af-011d8f95dc4f.png"><img width="380" alt="KakaoTalk_Photo_2020-06-07-08-49-40" src="https://user-images.githubusercontent.com/46921003/83956721-fdd1be00-a89b-11ea-82dc-d7a221a40fbc.png">

> 하트 수를 누적하는 데이터 통신
>
> 하트의 수를 1, 0 으로 쿼리에 저장하고 하트를 클릭하는대로 +1씩 증가하는 기능을 구현. Alamofire에서는 put의 방법으로 통신한다!

```swift
import Foundation
import Alamofire

struct HeartsServiceSE {
    static let shared = HeartsServiceSE()
    
    func heart(musicIdx: Int, isChecked: Int, completion: @escaping (NetworkResult<Any>) -> Void) {
        let header: HTTPHeaders = ["Content-Type": "application/json"]
        
        let dataRequest = Alamofire.request(APIConstants.heartsURL + "\(musicIdx)/\(isChecked)", method: .put, encoding: JSONEncoding.default, headers: header)
        
        dataRequest.responseData { dataResponse in
            switch dataResponse.result {
            case .success:
                guard let statusCode = dataResponse.response?.statusCode else { return }
                guard let value = dataResponse.result.value else { return }
                let networkResult = self.judge(by: statusCode, value)
                completion(networkResult)
            case .failure: completion(.networkFail)
            }
            
        }
    }
    
    private func judge(by statusCode: Int, _ data: Data) -> NetworkResult<Any> {
        switch statusCode {
        case 200: return decodeData(by: data)
        case 400: return .pathErr
        case 500: return .serverErr
        default: return .networkFail
        }
    }
    
    private func decodeData(by data: Data) -> NetworkResult<Any> {
        let decoder = JSONDecoder()
        guard let decodedData = try? decoder.decode(HeartsDataSE.self, from: data) else { return .pathErr }
        guard let musicData = decodedData.data else { return .requestErr(decodedData.message) }
        print(musicData)
        return .success(musicData[0])
    }
}

```





**이번 해커톤에서 잘 한 점**❗️❗️: 

- 각자 해본 뷰가 달라 뷰 분담이 쉬웠고 작업 내내 줌을 키고 파트원들과 소통하였기 때문에 온라인 협업이었음에도 불구하고 원활하게 작업을 했다!!
- 파트에 국한되지 않고 서로서로의 파트의 역할에 적극적으로 아이디어를 내고 일을 분담하였다!
- 아요 파트원 세명 모두 솝트 전으로는 iOS 개발이 전무한 YB(ㅠㅠ) 였기에 함께 삽질도 많이 했지만 맡은 뷰와 기능들을 끝까지 책임지고 포기하지 않았다!!
- 매우 고되고 외로운(?) 온라인 해커톤이었지만 너무도 긍정적이고 파이팅 넘치는 팀원들과 함께였기에 재밌었다!! 🔥🔥



**이번 해커톤에서 어려웠던 점**❗️❗️:

- Git으로 작업하는 것이 익숙치 않아 처음에 git으로 작업물을 주고 받는 것을 익히는데에 시간이 많이 소요되었다 ㅠㅠ 또 중간 중간 발생한 conflict를 해결하는데에도 해커톤 시간의 대부분을 뺏긴 것 같다.
- 데이터 통신이 확실히 너무 어렵다.. 앱잼 전까지 우리 모두 능숙하게 데이터 통신을 할 수 있도록 열심히 공부하기로 했다~!